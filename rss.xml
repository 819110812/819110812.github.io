<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>阿秋的blog</title>
    <link>https://newzone.top/</link>
    <description>菜鸡阿秋的博客。</description>
    <language>zh-CN</language>
    <pubDate>Sun, 28 Aug 2022 06:37:32 GMT</pubDate>
    <lastBuildDate>Sun, 28 Aug 2022 06:37:32 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>配置github sshkey</title>
      <link>https://newzone.top/deploy/github%20ssh%E9%85%8D%E7%BD%AE.html</link>
      <guid>https://newzone.top/deploy/github%20ssh%E9%85%8D%E7%BD%AE.html</guid>
      <source url="https://newzone.top/rss.xml">配置github sshkey</source>
      <pubDate>Sun, 28 Aug 2022 02:32:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="配置github-ssh-key" tabindex="-1"> 配置github ssh key</h2>
<div><pre><code>ssh-keygen <span>-t</span> rsa <span>-C</span> “xxx” <span>#后面跟你邮箱地址</span>
<span>cat</span> ~/.ssh/id_rsa.pub
</code></pre><div aria-hidden="true"><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>github+宝塔面板自动部署页面</title>
      <link>https://newzone.top/deploy/github+%E5%AE%9D%E5%A1%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.html</link>
      <guid>https://newzone.top/deploy/github+%E5%AE%9D%E5%A1%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.html</guid>
      <source url="https://newzone.top/rss.xml">github+宝塔面板自动部署页面</source>
      <pubDate>Sun, 28 Aug 2022 02:32:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="github-宝塔面板自动部署页面" tabindex="-1"> github+宝塔面板自动部署页面</h1>
<h2 id="服务器配置宝塔面板" tabindex="-1"> 服务器配置宝塔面板</h2>
<div><pre><code><span># ubuntu</span>
<span>wget</span> <span>-O</span> install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh <span>&amp;&amp;</span> <span>sudo</span> <span>bash</span> install.sh
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="安装webhook插件" tabindex="-1"> 安装webhook插件</h2>
<h2 id="配置回调脚本" tabindex="-1"> 配置回调脚本</h2>
<p>在首页选择到刚刚安装的webhook</p>
<p><img src="https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220828104943.png" alt="" loading="lazy"></p>
<p>点击添加hook
<img src="https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220828105058.png" alt="" loading="lazy">
在下面添加执行脚本</p>
<div><pre><code><span>cd</span> folder <span>#进入你的网页文件夹</span>
<span>git</span> pull
<span>## 配置部署脚本 如：</span>
<span>npm</span> <span>install</span>
<span>npm</span> build
<span>npm</span> run
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="在github配置webhook" tabindex="-1"> 在github配置webhook</h2>
<p><img src="https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220828101240.png" alt="" loading="lazy"></p>
<h2 id="方案分析" tabindex="-1"> 方案分析</h2>
<h3 id="优点" tabindex="-1"> 优点：</h3>
<ul>
<li>可视化界面，方便简单</li>
<li>可以查看日志</li>
</ul>
<h3 id="缺点" tabindex="-1"> 缺点：</h3>
<ul>
<li>需要手动配置很多环境</li>
<li>如果部署或者拉取失败，没有及时反馈机制</li>
</ul>
]]></content:encoded>
      <enclosure url="https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220828104943.png" type="image/png"/>
    </item>
    <item>
      <title>二叉树的遍历</title>
      <link>https://newzone.top/leetcode/Leetcode%20%E5%88%B7%E9%A2%9813%20--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%20%E5%88%B7%E9%A2%9813%20--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html</guid>
      <source url="https://newzone.top/rss.xml">二叉树的遍历</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题13-二叉树的遍历" tabindex="-1"> Leetcode刷题13 --二叉树的遍历</h1>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<div><pre><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解法1：借助辅助函数</p>
<div><pre><code><span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>inorderTraversal</span><span>(</span>self<span>,</span> root<span>:</span> TreeNode<span>)</span> <span>-</span><span>></span> List<span>[</span><span>int</span><span>]</span><span>:</span>
        res <span>=</span> <span>[</span><span>]</span>
        <span>if</span> root <span>is</span> <span>None</span><span>:</span>
            <span>return</span> res
        <span>def</span> <span>bfs</span><span>(</span>root<span>)</span><span>:</span>
            <span>if</span> root <span>is</span> <span>not</span> <span>None</span><span>:</span>
                dfs<span>(</span>root<span>.</span>left<span>)</span>
                res<span>.</span>append<span>(</span>root<span>.</span>val<span>)</span>
                dfs<span>(</span>root<span>.</span>right<span>)</span>

        dfs<span>(</span>root<span>)</span>
        <span>return</span> res
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解法二：传统递归</p>
<div><pre><code>class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        if root is None:
            return []
        if root is not None:
           return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该方法虽然看起来简洁，但是运行时间比第一个多很多</p>
]]></content:encoded>
    </item>
    <item>
      <title>二叉树的深度</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9801-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9801-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.html</guid>
      <source url="https://newzone.top/rss.xml">二叉树的深度</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题记录01-二叉树的深度" tabindex="-1"> Leetcode刷题记录01-二叉树的深度</h1>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<div><pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>返回它的最大深度 3 。</p>
<h3 id="python解法" tabindex="-1"> <em>Python解法</em></h3>
<ol>
<li>深度优先遍历</li>
</ol>
<div><pre><code>    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1  #比较左右子树哪个最深
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li>广度优先遍历
使用一个列表和计数器来遍历整个二叉树，每遍历一次计数器加1，并将列表更新</li>
</ol>
<div><pre><code>def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        arr,res = [root],0
        while arr:
            temp = []
            for node in arr:
                if node.left :temp.append(node.left)
                if node.right: temp.append(node.right)
            arr = temp
            res+=1
        return res
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>广度优先的方法利用的空间去置换出了递归时的时间，使得遍历更快</p>
<p>再用Java语言将二者实现一遍</p>
<p>2.Java版
写法一致，只是用来当做学习Java的一个途径
<em>DFS</em></p>
<div><pre><code>class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><em>BFS</em></p>
<div><pre><code>class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        List&lt;TreeNode> arr = new ArrayList&lt;>() {{ add(root); }}, tmp;
        int res = 0;
        while(!arr.isEmpty()) {
            tmp = new LinkedList&lt;>();
            for(TreeNode node : arr) {
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
            }
            arr = tmp;
            res++;
        }
        return res;
    }
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>平衡二叉树</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9802-%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9802-%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html</guid>
      <source url="https://newzone.top/rss.xml">平衡二叉树</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode-平衡二叉树" tabindex="-1"> Leetcode 平衡二叉树</h1>
<ol>
<li>
<p>什么是平衡二叉树（Balanced Binary Tree）
二叉树是一种二叉排序树，它的左右子树的高度不得超过一。这是这题的关键，至于树的维护，本文不会加以描述
<img src="https://img-blog.csdnimg.cn/2020052220375832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MzY0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">
[图片来源：百度图片]</p>
</li>
<li>
<p>基本思路
遇到二叉树的问题基本就是DFS，BFS走一波试试，这题采用了一个DFS的辅助函数，遍历过后计算树的高度
辅助函数：</p>
</li>
</ol>
<div><pre><code>def dfs(root):
	if not root: return 0
    return max(dfs(root.left), dfs(root.right)) + 1 #计算树的高度
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>很明显的可以看dfs的功能就是来计算树的一个高度。结合原先的函数，完整的代码就是：</p>
<div><pre><code>class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if root is None:
            return True

        def dfs(root):
            if not root: return 0
            return max(dfs(root.left), dfs(root.right)) + 1

        return abs(dfs(root.left) - dfs(root.right)) &lt;=1 and self.isBalanced(root.left) and self.isBalanced(root.right)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果是空树，则为True,必然是平衡树。
返回需要以下条件同时成立：</p>
<ul>
<li>当前子树是平衡树 即（abs(dfs(root.left) - dfs(root.right)) &lt;=1）</li>
<li>左子树是平衡树 即  self.isBalanced(root.left)</li>
<li>右子树是平衡树 即 self.isBalanced(root.right)</li>
</ul>
<p>提交的结果运行时间不是很优秀，还有待改善！</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/2020052220375832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MzY0Mg==,size_16,color_FFFFFF,t_70" type="image/"/>
    </item>
    <item>
      <title>对称二叉树</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9803-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9803-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html</guid>
      <source url="https://newzone.top/rss.xml">对称二叉树</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题03-对称二叉树" tabindex="-1"> Leetcode刷题03-对称二叉树</h1>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<div><pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<div><pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>示例 1：</p>
<div><pre><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>示例 2：</p>
<div><pre><code>输入：root = [1,2,2,null,3,null,3]
输出：false
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>来源：力扣（LeetCode）
链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p>
<p>题目要求判断一个二叉树是否平衡，看到二叉树，第一想到的是递归，然后是深度优先或者广度优先。在构建递归方法，三步走，
1.确定我们的递归程序的功能：判断是否对称，则返回值是false 或者是true
2.函数的输入是什么？
root.left,root.right. 为什么？ 我的理解是，因为要判断是否对称，那就要输入两边的子树进行比较，如果只是单独的root,递归过程很难去判断
3. 何时终止/边界条件？
如果都空，则完全一样，返回true,如果传入的左右节点有一个是空的，则不对称，则返回false。
此外还要实现判断对称的过程，即，传入的两节点值一样，且（1）左节点的左子树值等于右节点的右子树值，（2） 左节点的右子树值等于右节点的左子树值</p>
<p>先贴一下本菜鸡的实现方法：</p>
<div><pre><code>def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        def dfs(left,right):
            if not left and not right:
                return True
            if not left or not right:
                return False
            return left.val==right.val and dfs(left.left,right.right) and dfs(left.right,right.left) 
        return dfs(root.left,root.right)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>定义了一个辅助函数对传入节点进行判断并进行递归。
下面是官方的写法：</p>
<div><pre><code>def isSymmetric(self, root: TreeNode) -> bool:
        def recur(L, R):
            if not L and not R: return True
            if not L or not R or L.val != R.val: return False
            return recur(L.left, R.right) and recur(L.right, R.left)

        return recur(root.left, root.right) if root else True
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>作者：jyd
链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/</a>
来源：力扣（LeetCode）</p>
<p>思路大致相同，但是官方的显得更加简单干练，将Python语言特性发挥的淋漓尽致。</p>
<p>大致总结一下思路过程：
看到二叉树，想到要去写个递归，然后考虑这个递归的要素怎么设计，递归的主要实现，最后再去优化。</p>
]]></content:encoded>
    </item>
    <item>
      <title>股票的最大利润</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9804-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9804-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6.html</guid>
      <source url="https://newzone.top/rss.xml">股票的最大利润</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题04-股票的最大利润" tabindex="-1"> Leetcode刷题04-股票的最大利润</h1>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:</p>
<div><pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，
最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>示例 2:</p>
<div><pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>一看到这题，第一反应就是动态规划，为什么是动态规划呢？因为这题是就最值，一般求最值问题，动态规划来解会得心应手。既然是动态规划，那么就要考虑到我们的状态转移方程是什么。
从题目中可以得到这么一个信息，股票是低买高卖，那么就需要记录下一个极小值，并且要做一个取舍，当前的价格减去最小值的利润是否比之前的最大利润多。
大致的一个思路就是这样，那么我们的状态转移方程则是：</p>
<div><pre><code>dp[i] = max(prices[i]-temp,dp[i-1])
</code></pre><div aria-hidden="true"><div></div></div></div><p>dp[i] 则是记录我们的当前最大值， max(prices[i]-temp,dp[i-1])则是在取最大的情况存进我们的dp列表中。
完整的代码是这样的：</p>
<div><pre><code>from typing import List


class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        dp = [0]*len(prices)  # 初始化我们的dp列表
        temp = prices[0] #将第一天的价格记做暂时的最小值
        for i in range(1,len(prices)):
            if prices[i]&lt;=temp: #如果有更小的则更新
                temp = prices[i]
            dp[i] = max(prices[i]-temp,dp[i-1])
        return dp[len(prices)-1] #返回最终的结果 



if __name__ == '__main__':
    stock = [7,6,4,3,1]
    sol = Solution()
    print(sol.maxProfit(stock)) #返回5
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的写法算是很中规中矩的动态规划写法，来看下官方给出的解法</p>
<div><pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        cost, profit = float(&quot;+inf&quot;), 0
        for price in prices:
            cost = min(cost, price)
            profit = max(profit, price - cost)
        return profit

作者：jyd
链接：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/
来源：力扣（LeetCode）
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>基本思路是一致的，都是记录下当前的最小值和最大利润，然后计算判断，不过官方的明显要比我自己写的简练很多，hmmmm，还有好多要走呢，奥利给！</p>
]]></content:encoded>
    </item>
    <item>
      <title>礼物最大的价值</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9805---%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9805---%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC.html</guid>
      <source url="https://newzone.top/rss.xml">礼物最大的价值</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题05-礼物的最大价值" tabindex="-1"> Leetcode刷题05---礼物的最大价值</h1>
<p>本题来自剑指offer的47题</p>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 1:</p>
<div><pre><code>输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>分析一下解题思路，这个题目的类型很明确，求极值，只不过加了一点类似路径的内容，本质还是一个求极值的问题，那么就立马想到用动态规划去做。将问题细分至最小子问题，我们要求最值，那么在最后一个时刻的最值就应该是由前一时刻的最大值+当前的值。那么状态转移方程就是 <code> dp[i][j] = max(dp[i][j-1],dp[i-1][j]) + grid[i][j]</code>，这么直接写进去会出现一个问题，就是边界值的问题，在边界的处理上需要做一些额外的判断，我们可以直接将我们的dp矩阵扩张一下，为什么这么做呢？因为我们要考虑到左上角的情况，这个时候 i,j都是0，为了解决这个问题我们可以将遍历的范围从1开始计，那么dp[1]][1] 就对应了grid[0][0]的值，所以在写的时候 应该是 <code> dp[i][j] = max(dp[i][j-1],dp[i-1][j])+grid[i-1][j-1]</code>。同时我们的遍历范围也需要跟着扩展，完整的代码是</p>
<div><pre><code>class Solution:
    def maxValue(self, grid: List[List[int]]) -&gt; int:
       dp = [[0]*(len(grid[0])+1)]*(len(grid)+1)
       for i in range(1,len(grid)+1):
           for j in range(1,len(grid[0])+1):
               dp[i][j] = max(dp[i][j-1],dp[i-1][j])+grid[i-1][j-1]
        return dp[-1][-1]


if __name__ == '__main__':
    arr = [[1,2,5],[3,2,1]]
    sol = Solution()
    print(sol.maxValue(arr)) #返回9  dp矩阵为[[0, 4, 6, 9], [0, 4, 6, 9], [0, 4, 6, 9]]

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>整体代码，额外空间 O（mn），时间O（mn）
日常看一眼官方给出的代码：</p>
<div><pre><code>class Solution:
    def maxValue(self, grid: List[List[int]]) -&gt; int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0 and j == 0: continue
                if i == 0: grid[i][j] += grid[i][j - 1]
                elif j == 0: grid[i][j] += grid[i - 1][j]
                else: grid[i][j] += max(grid[i][j - 1], grid[i - 1][j])
        return grid[-1][-1]

作者：jyd
链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/
来源：力扣（LeetCode）

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>解释性很强，考虑了很细致的情况</p>
<ul>
<li>通用情况： 数值不在边界上，那么就是它的上面一个元素和左边一个元素比大小，取最大的和自己相加，即 <code> max(dp[i-1] [j],dp[i][j-1])+grid[i][j]</code></li>
<li>考虑到边界情况，如果是第一个点，即左上角那个点，则是直接赋值：<code> dp[i][j]=0</code></li>
<li>如果在第一行，则只能在左边寻找到极值， 即 <code> dp[i][j] = dp[i][j-1]+grid[i][j]</code></li>
<li>如果在第一列却不在第一行，就是在最左边的边边上，我们的极值就是上面那个元素，即 <code>dp[i][j] = dp[i-1][j]+grid[i][j]</code>
很妙的是，这边用的原地修改，这样额外空间就不会很大。</li>
</ul>
<div><pre><code>class Solution:
    def maxValue(self, grid: List[List[int]]) -&gt; int:
        m, n = len(grid), len(grid[0])
        for j in range(1, n): # 初始化第一行
            grid[0][j] += grid[0][j - 1]
        for i in range(1, m): # 初始化第一列
            grid[i][0] += grid[i - 1][0]
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += max(grid[i][j - 1], grid[i - 1][j])
        return grid[-1][-1]

作者：jyd
链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/
来源：力扣（LeetCode）
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这是官方给出的第二种解法，提前初始化，减少了判断的冗余，hmmmm，妙啊！
回顾一下自己的写法，相比之下，解释性不是那么的通俗易懂，额外空间偏大。</p>
]]></content:encoded>
    </item>
    <item>
      <title>二分查找</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9806--%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9806--%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</guid>
      <source url="https://newzone.top/rss.xml">二分查找</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题06-二分查找" tabindex="-1"> Leetcode刷题06--二分查找</h1>
<p>刷一道经典的算法，二分查找，虽然是经典算法但是有很多细节在写的时候也是要注意的，不经意间可能就会少加个1多加个1</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<div><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>示例 2:</p>
<div><pre><code>输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>解法1：
传统二分查找</p>
<div><pre><code>def search(self, nums: List[int], target: int) -&gt; int:
		left,right = 0,len(nums)-1
		while left&lt;=right:
			mid = (right+left)//2  # 地板除
			if target&lt; nums[mid]: right = mid-1 #如果小于，则说明目标值出现在mid的左侧
			elif target &gt; nums[mid]: left = mid+1 #如果大于，则说明目标出现在mid的右侧
			else: return mid # 如果等于，直接返回mid，就是我们要的目标索引
		return	-1 #不存在就返回-1

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="https://img-blog.csdnimg.cn/20200530135114938.png" alt="在这里插入图片描述" loading="lazy">
运行的效率不是很高。当然也可以用抖机灵的方法来实现：</p>
<p>解法2：</p>
<div><pre><code>def search(self, nums: List[int], target: int) -&gt; int:
		if target in nums:
			return nums.index(target)
		eles:
			return -1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这种方法，简洁，但是效率不高，因为你有一个<code>in</code>操作这个是O（n）的时间复杂度。</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20200530135114938.png" type="image/png"/>
    </item>
    <item>
      <title>二叉树的层序遍历</title>
      <link>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9807%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html</link>
      <guid>https://newzone.top/leetcode/Leetcode%E5%88%B7%E9%A2%9807%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html</guid>
      <source url="https://newzone.top/rss.xml">二叉树的层序遍历</source>
      <pubDate>Sat, 27 Aug 2022 13:41:52 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="leetcode刷题07-二叉树的层序遍历" tabindex="-1"> Leetcode刷题07 - 二叉树的层序遍历</h1>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：</p>
<div><pre><code>二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我的解法：</p>
<div><pre><code>def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root : 
            return []
        arr , res = [root],[]
        while arr:
            temp = []
            temp_res = []
            for node in arr:
                temp_res.append(node.val)
                if node.left: temp.append(node.left)
                if node.right:temp.append(node.right)
            arr = temp
            res.append(temp_res)
        return res
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>广度优先遍历，但是很明显，这个写法的内存消耗很是严重啊。优化方法暂时还没想到，看到的很多写法都和这个类似，区别在于部分使用到了队列来实现，但是跑下来效果没差，hmmmm，优化方法暂且放到一边，待日后再整。
贴一波使用队列的方法：</p>
<div><pre><code>def levelOrder(self, root):
		queue = collections.deque()
        queue.append(root)
        res = []
        while queue:
            size = len(queue)
            level = []
            for _ in range(size):
                cur = queue.popleft()
                if not cur:
                    continue
                level.append(cur.val)
                queue.append(cur.left)
                queue.append(cur.right)
            if level:
                res.append(level)
        return res

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
  </channel>
</rss>