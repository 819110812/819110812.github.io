---
article: true 
title: 聊一聊分布式系统中的TCC
star: false
tag: arch
order: 1

---

# 聊一聊分布式系统中的TCC

## 写在开头

在微服务软件架构中，分布式事务一直是大家关系的一个问题，相关的解决方案也有很多，在这篇文章中，我主要是想讨论两个常见的分布式事务机制，TCC和SAGA。

## TCC

### 什么是TCC?

TCC是“try-confirm-cancle”三个单词的缩写。最早是由Pat Helland于2007年发表的一篇论文中提出来的一个概念。TCC有点类似于XA两阶段提交，但是它不会依赖于资源管理的支持，而是通过对业务逻辑的调度来实现的分布式事务。

### 与传统的XA两阶段提交有什么不一样的地方呢？

#### 先回顾一下传统的XA是什么样的

XA协议是一个两阶段提交的协议，它可以直接作用于很多数据库当中，它通过协调访问多个关系型数据库的单个事务来确保数据的完整性。它的两阶段提交主要分为： `prepare`和`commit`两个阶段。我们从一个例子里来看XA是如何工作的



> 电商场景：
> 
> 用户在商店里买了一件商品，并成功付款了，要确保整件事发生，需要成功处理这么几件事：
> 
> - 用户的账号应该被扣减对应的价格
> 
> - 库存减少了
> 
> - 对应生成了新的订单，并且订单状态是已付款
> 
> - 商家的账款也相应增加了

在这么一个典型的场景中，我们可以大概的分一下可能这个场景中涉及到的服务有这么几个：订单服务，库存服务，和账户服务。我们的程序要确保一件事就是如果用户下了订单并且付款成功了，我们这三个服务的数据应该都是一致的，如果一个服务在处理过程中出现了问题，我们应该告诉用户交易失败并且数据中不会存在这么一条出错的记录。

首先是第一阶段：

> 第一阶段： 准备提交

![](https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220911141513.png)

如果有一方没有准备好，那么这次请求就会回滚。当所有服务都准备好做提交时，才会发生第二阶段的提交操作。



> 第二阶段： 提交

![](https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220911150456.png)


### XA协议的痛点

XA的实现是要结合锁来确保在数据提交前，目标数据不会其他并发的请求提前修改，那么随之而来的问题就是性能问题，还有各种隔离级别设置的坑。

#### TCC和它有什么有什么不一样的？

我觉得最大的区别之一就是，XA是直接作用于资源层面的，而TCC是作用与服务层面的。如果再激进一点，甚至可以说是两个东西，只是二者在功效上有点类似。XA是一种协议，而TCC是一种编程模式。



### TCC是如何工作的？

TCC的工作原理就如他的名字一样，分为 `try` ,  `confirm`, `cancle`。 `try`对应二阶段提交的`prepare`阶段，`confirm`对应`commit`阶段，而`cancle`就是失败后的回滚操作了。

TCC三阶段落实到我们的代码中，也就三个方法来实现。代码的流程图如下图：

<img title="" src="https://golearning.oss-cn-shanghai.aliyuncs.com/obsidian20220911145118.png" alt="" data-align="center">

具体的代码实现会在另外一篇文章中详细描述。



### TCC带来的问题

- TCC是代码侵入的方式，为了适配TCC的模式，我们需要将代码逻辑拆成TCC的模式才可以

- 为了达到的TCC的效果，我们需要把接口设计成幂等才可以







### 引用

- [分布式事务中的二阶段提交是什么？ - 金融分布式架构 SOFAStack - 阿里云](https://help.aliyun.com/document_detail/132896.html)

- [6 张图带你彻底搞懂分布式事务 XA 模式-阿里云开发者社区](https://developer.aliyun.com/article/783796)

- 
